{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 5. Rewrite the following nested function call using BaseR\'92s chaining operator:\
\
arrange(filter(select(as_tibble(iris), starts_with("Petal"), Species),\
Petal.Length < 1.55), Species)\
\
> as_tibble(iris) |> filter(Petal.Length < 1.55) |> arrange(Species) |> select(starts_with("Petal"), Species)\
\
```\{r include = FALSE\}\
library(tidyverse)\
\
#nested\
nested <- arrange(filter(select(as_tibble(iris), starts_with("Petal"), Species),\
Petal.Length < 1.55), Species)\
\
#Print tibble\
nested\
\
#chained\
#filter first since, in theory (see notes) you might not subset with that variable\
#same with arrange, though more likely to keep variable\
chained <- as_tibble(iris) |> filter(Petal.Length < 1.55) |> arrange(Species) |> select(starts_with("Petal"), Species)\
\
#Print tibble\
chained\
\
#Check to confirm that the tibbles are equal\
isTRUE(all.equal(nested,chained))\
\
```}